<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <!-- Babylon, Tensorflow & poseNet -->
    <script src="https://cdn.babylonjs.com/babylon.max.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>

    <title>PoseNet test</title>
</head>
<body>
    <canvas id="canvas"></canvas>
    <video id="video" autoplay playsinline muted width="320" height="180" src=""></video>
    <script type="module">

        // ------------------------------------ globaal ------------------------------------
        const $video = document.getElementById("video");

        const leftEyeX = document.createElement("p");
        leftEyeX.classList.add("xCO");
        leftEyeX.textContent = '';

        const leftEyeY = document.createElement("p");
        leftEyeY.classList.add("yCO");
        leftEyeY.textContent = '';
        
        let xValue;
        let player;

        // ------------------------------------ camera ------------------------------------

        const camera = async () => {
            requestAnimationFrame(render);
            const options = { audio: false, video: { width: 320, height: 180} };
            let stream = await navigator.mediaDevices.getUserMedia(options);
            $video.srcObject = stream;

            if(!$video.captureStream) {
                $video.captureStream = () => stream;
            }
        }

        const render = (time) => {
            time *= 0.001;  
            requestAnimationFrame(render);
        }

        // ------------------------------------ posenet ------------------------------------

            const runPoseNet = async () =>Â {
                await camera();
                const net = await posenet.load({
                inputResolution:{width:640, height:480},
                scale: 0.5
                });

                setInterval(() => {
                    detect(net );
                }, 100 );
            };
        
        const detect = async (net) => {
            //make detections
            const pose = await net.estimateSinglePose(video);
            // console.log(pose);

            const outputX = pose.keypoints[1].position.x;
            const outputY = pose.keypoints[1].position.y;

            if (outputX >= 200 && outputX < 350) {
                xValue = 3;
                } else if (outputX >= 130 && outputX < 200){
                    xValue = 0
                    } else if (outputX >= 0 && outputX < 130){
                        xValue = -3;
            };

            leftEyeX.textContent = outputX  
            leftEyeY.textContent = outputY;
            document.body.appendChild(leftEyeX);
            document.body.appendChild(leftEyeY);

            return xValue ;
        }

        // ------------------------------------ babylon ------------------------------------
        const setUp = () => {
            const canvas = document.getElementById('canvas');
            const engine = new BABYLON.Engine(canvas, true);
            const createScene = function () {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(0.65, 0.81, 0.67);

                //camera
                const camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 3, -10), scene);
                camera.setTarget(BABYLON.Vector3.Zero());
                camera.attachControl(canvas, true);

                //Lichtinval
                var light = new BABYLON.PointLight("light", new BABYLON.Vector3(0, 0, -3), scene);
                light.intensity = .3;
                
                //Player
                player = BABYLON.Mesh.CreateBox("Player", 1.6, 0, scene);
                player.position = new BABYLON.Vector3(0, -2, -2);
                
                const material1 = new BABYLON.StandardMaterial("material1", scene);
                material1.emissiveColor = BABYLON.Color3.Red();
                player.material = material1;
                //Obstakels
                const box1 = BABYLON.Mesh.CreateBox("Box1", 1.5, 0, scene);
                const box2 = BABYLON.Mesh.CreateBox("Box2", 1.5, 0, scene);
                const box3 = BABYLON.Mesh.CreateBox("Box3", 1, 0, scene);
                const box4 = BABYLON.Mesh.CreateBox("Box4", .5, 0, scene);
                const box5 = BABYLON.Mesh.CreateBox("Box5", .5, 0, scene);

                box1.position = new BABYLON.Vector3(-3,  -2, 3);
                box2.position = new BABYLON.Vector3(3,  -2, 1);
                box3.position = new BABYLON.Vector3(0,  -2, 6);
                box4.position = new BABYLON.Vector3(-3,  -2, 12);
                box5.position = new BABYLON.Vector3(3,  -2, 15);

                //Ground
                const ground = BABYLON.MeshBuilder.CreateGround("gd", {width: 12, height: 30, subdivsions: 4}, scene);
                ground.position = new BABYLON.Vector3(0,-3,10);

                const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
                groundMaterial.emissiveColor = new BABYLON.Color3(0.85, 0.77, 0.60);
                ground.material = groundMaterial;

                //keyboard input "w" en "x"
                scene.onKeyboardObservable.add((kbInfo) => {
                    switch (kbInfo.type) {
                        case BABYLON.KeyboardEventTypes.KEYDOWN:
                            switch (kbInfo.event.key) {
                                case "w":
                                case "W" : 
                                    player.position.x -= 3;
                                break;
                                case "x":
                                case "X":
                                    player.position.x += 3;
                                break;
                            }
                        break;
                    }
                });

                return scene;
            }

            const scene = createScene();

            engine.runRenderLoop(function () {
            //  hier moet de variabele gerendert worden.
            // player variabele kan je hier kopppelen aan het posenet variabele gedeelte
                player.position.x = xValue;
                console.log(xValue); 
                scene.render();
            });
            
        }
        window.addEventListener('DOMContentLoaded', setUp());

        camera();
        runPoseNet();
       
    </script>


</body>
</html>